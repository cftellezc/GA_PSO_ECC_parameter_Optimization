import random
from secrets import randbelow
import hmac
import hashlib
import os

# ECCParameters class represents the parameters of an elliptic curve over a finite field of prime order. 
class ECCParameters:
    def __init__(self, p, a, b, G, n, h):
        self.p = p  # The prime number that defines the finite field, i.e., all the operations will be performed modulo p
        self.a = a  # The coefficient 'a' in the equation of the elliptic curve y^2 = x^3 + ax + b
        self.b = b  # The coefficient 'b' in the equation of the elliptic curve y^2 = x^3 + ax + b
        self.G = G  # The base point (x, y) on the elliptic curve, which is a point of order n
        self.n = n  # The order of the group generated by G, i.e., the smallest positive integer n such that nG = O, where O is the point at infinity
        self.h = h  # The cofactor, which is the ratio between the number of points on the curve and n

"""
ECPoint represents a point on an elliptic curve. Each instance has x, y coordinates 
and a 'inf' flag to indicate if the point is at infinity. If x and y are None, 
'inf' is True, representing the 'point at infinity', the 'zero element' in elliptic 
curve addition. Otherwise, 'inf' is False and x, y represent the point's coordinates.
"""
class ECPoint:
    # Constructor for the ECPoint class
    def __init__(self, x, y):
        # Check if the given coordinates are None, which represents the point at infinity
        if x is None and y is None:
            # If so, set the x and y attributes to None and the inf attribute to True
            self.x = None
            self.y = None
            self.inf = True
        else:
            # If the coordinates are not None, they represent a regular point on the elliptic curve
            # Set the x and y attributes to the given coordinates and the inf attribute to False
            self.x = x  # x-coordinate of the point
            self.y = y  # y-coordinate of the point
            self.inf = False

# Function to add two points P and Q on an elliptic curve. This function uses the rules for elliptic curve point addition.
def ec_addition(P, Q, params):
    # If one of the points is the point at infinity, the result is the other point
    if P is None or P.inf:
        return Q
    if Q is None or Q.inf:
        return P

    # If P and Q are negatives of each other (i.e., they are additive inverses), the result is the point at infinity
    if P.x == Q.x and P.y == -Q.y % params.p:
        return ECPoint(None, None)  # Return a new point at infinity

    # Compute the slope of the line through P and Q, or the slope of the tangent line at P if P == Q
    if P.x == Q.x and P.y == Q.y:
        # The points are the same, so use the formula for the slope of the tangent line at the point
        m = (3 * P.x * P.x + params.a) * pow(2 * P.y, -1, params.p) % params.p
    else:
        # The points are different, so use the formula for the slope of the line through the points
        m = (Q.y - P.y) * pow(Q.x - P.x, -1, params.p) % params.p

    # Compute the coordinates of the sum of the points
    x = (m * m - P.x - Q.x) % params.p
    y = (m * (P.x - x) - P.y) % params.p

    return ECPoint(x, y)

# Function to multiply a point P on an elliptic curve by a scalar (integer). This function uses the double-and-add algorithm.
def ec_scalar_multiplication(P, scalar, params):
    result = ECPoint(None, None)  # Start with the point at infinity
    current = P  # Start doubling from the point P

    # Continue until the scalar is exhausted
    while scalar:
        # If the current bit of the scalar is 1, add the current point to the result
        if scalar & 1:
            if result.x is None:  # First operation
                result = current
            else:
                result = ec_addition(result, current, params)

        # Double the current point
        current = ec_addition(current, current, params)

        # Move to the next bit of the scalar
        scalar >>= 1

    print(f"Final scalar multiplication result: {result.x}, {result.y}")
    return result


# Function to generate a random private key, which is a random integer in the range [1, n-1]
def generate_private_key(params):
    return randbelow(params.n - 1)

# Function to generate the public key corresponding to a given private key. The public key is the result of multiplying the base point G by the private key.
def generate_public_key(private_key, params):
    return ec_scalar_multiplication(params.G, private_key, params)

def is_valid_point(point, params):
    """
    Check if a point is valid on an elliptic curve.
    """
    x, y = point.x, point.y

    # Elliptic curve equation: y^2 = x^3 + ax + b (mod p)
    return (y * y - x * x * x - params.a * x - params.b) % params.p == 0

def is_valid_scalar(k, params):
    """
    Check if a scalar is valid in the field defined by the order of the group of points on the elliptic curve.
    """
    # k should be an integer between 0 and n-1
    return 0 <= k < params.n

def encrypt_message(message, public_key, params):
    # Check that the public key is a valid point on the curve
    if not is_valid_point(public_key, params):
        raise ValueError("Public key is not a valid point on the elliptic curve")

    # Generate a random integer for use as an ephemeral key
    k = generate_private_key(params)

    # Check that the scalar is valid
    if not is_valid_scalar(k, params):
        raise ValueError("Invalid scalar value")

    # Compute the two points C1 = kG and C2 = kQ
    C1 = ec_scalar_multiplication(params.G, k, params)
    C2 = ec_scalar_multiplication(public_key, k, params)

    # Convert the message to bytes
    message_bytes = message.encode('utf-8')

    encrypted_message = []

    # For each byte of the message, compute the XOR with the least significant byte of the x-coordinate of C2
    for byte in message_bytes:
        if C2.x is None:
            raise ValueError("Encryption failed: kQ resulted in the point at infinity")
        encrypted_byte = byte ^ (C2.x & 0xFF)
        encrypted_message.append(encrypted_byte)

    return C1, encrypted_message


# Function to decrypt an ECC-encrypted message
def decrypt_message(C1, encrypted_message, private_key, params):

    try:
        # Compute the point C2 = C1 * private_key
        C2 = ec_scalar_multiplication(C1, private_key, params)
    except Exception as e:
        print(f"An error occurred during decryption: {str(e)}")
        return None

    decrypted_message_bytes = bytearray()

    # For each byte of the encrypted message, compute the XOR with the least significant byte of the x-coordinate of C2
    for encrypted_byte in encrypted_message:
        byte = encrypted_byte ^ (C2.x & 0xFF)
        decrypted_message_bytes.append(byte)

    # Convert the decrypted bytes back to a string
    decrypted_message = decrypted_message_bytes.decode('utf-8')

    return decrypted_message

# Function to initialize the ECC parameters for a specific elliptic curve
def initialize_params(option):
    filename_map = {
        "1": "ga_ecc_params.txt",
        "2": "pso_ecc_params.txt",
        "3": "secp256k1.txt",
        "4": "brainpoolP256r1.txt",
    }
    
    filename = filename_map[option]  # Lookup the filename using the given option
    filepath = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'ecc_parameters', filename)

    with open(filepath, 'r') as f:
        params_dict = {}
        for line in f:
            key, value = line.strip().split(': ')
            params_dict[key] = int(value)
        
    p = params_dict['p']
    a = params_dict['a']
    b = params_dict['b']
    G = ECPoint(params_dict['G_x'], params_dict['G_y'])
    n = params_dict['n']
    h = params_dict['h']

    print(f'\n\nKind of ECC parameters to use: {filename}')
    print(f'\nECC Parameters are: \np: {p}, \na: {a}, \nb: {b}, \nG: ({G.x}, {G.y}), \nn: {n}, \nh: {h}')

    return ECCParameters(p, a, b, G, n, h)


# Function to generate an HMAC of a message using a given key
def generate_hmac(key, message):
    return hmac.new(key, message.encode('utf-8'), hashlib.sha256).digest()

# Function to verify the HMAC of a message using a given key and a received HMAC
def verify_hmac(key, message, received_hmac):
    calculated_hmac = generate_hmac(key, message)
    return hmac.compare_digest(calculated_hmac, received_hmac)
